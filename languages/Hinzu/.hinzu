[
  l([
      id(hinzu),
      name('Hinzu'),
      description('A trivial metadata/annotation language designed to facilitate basic documentation and semantic annotation of languages in the YAS repository.'),
      relatesTo(hasPurpose, id(metadata)),
      relatesTo(hasPurpose, id(mega))
  ]),
  r([
      id(hinzu(term)),
      extension(hinzu),
      relatesTo(representationOf, id(hinzu))
  ]),

%
% We self-describe all qualifiers below.
%
  q([
      id(sameAs),
      description('One entity (e.g., a language in the repository at hand) is the "same" (ontologically) as an entity in the same or another "ontology" (e.g., a page on Wikipedia which describes the entity of interest). This concept is inspired by the Semantic Web. The idea is that "sameAs" is the strongest form of an "identity link".'),
      relatesTo(linksTo, uri('https://www.w3.org/2009/12/rdf-ws/papers/ws21')),
      relatesTo(linksTo, uri('http://disi.unitn.it/~p2p/RelatedWork/Matching/data_linking_for_the_semantic_web.pdf'))
  ]),
  q([
      id(similarTo),  
      description('This is a weaker form of an "identity link" where the related entities are considered only similar but not the same in an ontological sense.'),
      relatesTo(similarTo, id(sameAs))
  ]),
  q([
      id(linksTo),  
      description('The relationship between the two entities is unclear.'),
      relatesTo(linksTo, id(sameAs))
  ]),
  q([
      id(hasPurpose),  
      description('An entity (e.g., a language) has a certain purpose (e.g., (to facilitate) functional programming).')
  ]),
  q([
      id(representationOf),  
      description('An entity (e.g., a language representation) represents another entity (e.g., a language. More concretely, the text-based representation of Java represents the Java language.')
  ]),
  q([
      id(subsetOf),  
      description('One entity (here: a language in the repository at hand) is a "subset" of another entity (here: another language in the repository at hand). In the case of languages, we view them as sets, e.g., in the sense of the text- or AST-based representation, with or without well-formedness checking applied, thereby enabling an obvious subset relationship.'),
      relatesTo(linksTo, id(supersetOf))
  ]),
  q([
      id(supersetOf),  
      description('One entity (here: a language in the repository at hand) is a "superset" of another entity (here: another language in the repository at hand). In the case of languages, we view them as sets, e.g., in the sense of the text- or AST-based representation, with or without well-formedness checking applied, thereby enabling an obvious superset relationship.'),
      relatesTo(linksTo, id(subsetOf))
  ]),
  q([
      id(dependsOn),  
      description('One entity (e.g., a language in the repository at hand) "depends", in some sense, on another entity (e.g., a language in the repository at hand). For instance, a transformation or differencing language may depend on another language in the sense that the semantics of the former language assumes elements of the latter language as input. One should use the more specific qualifiers for supersets or embedding, when they are appropriate.'),
      relatesTo(linksTo, id(supersetOf)),
      relatesTo(linksTo, id(embeds))
  ]),
  q([
      id(embeds),  
      description('A language in the repository at hand "embeds" another language in the repository at hand in the sense of that elements of the former language somehow may contain elements of the latter language. For instance, some imperative or functional programming language may embed a basic expression language, as the underlying expression forms are also needed in these programming languages.')
  ]),

%
% We collect all purposes below.
%

  p([
      id(abssyn),
      name('Abstract syntax definition')
  ]),
  p([
      id(algspec),
      name('Algebraic specification')
  ]),
  p([
      id(behavior),
      name('Behavioral modeling')
  ]),
  p([
      id(build),
      name('Build management')
  ]),
  p([
      id(compilation),
      name('Compilation')
  ]),
  p([
      id(textsyn),
      name('Concrete textual syntax definition')
  ]),
  p([
      id(concsyn),
      name('Concrete syntax definition')
  ]),
  p([
      id(datadef),
      name('Data definition')
  ]),
  p([
      id(dataexchange),
      name('Data exchange')
  ]),
  p([
      id(fp),
      name('Functional programming')
  ]),
  p([
      id(grammartrafo),
      name('Grammar transformation')
  ]),
  p([
      id(graphrepr),
      name('Graph representation')
  ]),
  p([
      id(graphviz),
      name('Graph visualization')
  ]),
  p([
      id(ip),
      name('Imperative programming')
  ]),
  p([
      id(langdef),
      name('Language definition')
  ]),
  p([
      id(metadata),
      name('Metadata definition')
  ]),
  p([
      id(metamodeling),
      name('Metamodeling')
  ]),
  p([
      id(mega),
      name('Megamodeling')
  ]),
  p([
      id(modeldiff),
      name('Model differencing')
  ]),
  p([
      id(oop),
      name('Object-oriented programming')
  ]),
  p([
      id(parsing),
      name('Parsing'),
      relatesTo(sameAs, uri('https://en.wikipedia.org/wiki/Parsing'))
  ]),
  p([
      id(parsegen),
      name('Parser generation')
  ]),
  p([
      id(parsetree),
      name('Parse-tree representation')
  ]),
  p([
      id(regress),
      name('Regression testing')
  ]),
  p([
      id(scripting),
      name('Scripting')
  ]),
  p([
      id(serialization),
      name('Serialization')
  ]),
  p([
      id(toy),
      name('Toy example')
  ]),
  p([
      id(treerepr),
      name('Tree representation')
  ])
].
